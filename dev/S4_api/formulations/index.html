<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Formulations · PDMO.jl Documentation</title><meta name="title" content="Formulations · PDMO.jl Documentation"/><meta property="og:title" content="Formulations · PDMO.jl Documentation"/><meta property="twitter:title" content="Formulations · PDMO.jl Documentation"/><meta name="description" content="Documentation for PDMO.jl Documentation."/><meta property="og:description" content="Documentation for PDMO.jl Documentation."/><meta property="twitter:description" content="Documentation for PDMO.jl Documentation."/><meta property="og:url" content="https://alibaba-damo-academy.github.io/PDMO.jl/S4_api/formulations/"/><meta property="twitter:url" content="https://alibaba-damo-academy.github.io/PDMO.jl/S4_api/formulations/"/><link rel="canonical" href="https://alibaba-damo-academy.github.io/PDMO.jl/S4_api/formulations/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">PDMO.jl Documentation</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../S1_getting_started/">Getting Started</a></li><li><span class="tocitem">Algorithms</span><ul><li><a class="tocitem" href="../../S2_algorithms/AdaPDM/">AdaPDM</a></li><li><a class="tocitem" href="../../S2_algorithms/ADMM/">ADMM</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../../S3_examples/DistributedOPF/">Distributed OPF</a></li><li><a class="tocitem" href="../../S3_examples/DualLasso/">Dual Lasso</a></li><li><a class="tocitem" href="../../S3_examples/DualSVM/">Dual SVM</a></li><li><a class="tocitem" href="../../S3_examples/FusedLasso/">Fused Lasso</a></li><li><a class="tocitem" href="../../S3_examples/LeastL1Norm/">Least L1 Norm</a></li></ul></li><li><span class="tocitem">API Reference</span><ul><li><a class="tocitem" href="../main/">Main</a></li><li class="is-active"><a class="tocitem" href>Formulations</a></li><li><a class="tocitem" href="../functions/">Functions</a></li><li><a class="tocitem" href="../mappings/">Mappings</a></li><li><a class="tocitem" href="../admm/">ADMM</a></li><li><a class="tocitem" href="../pdm/">AdaPDM</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">API Reference</a></li><li class="is-active"><a href>Formulations</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Formulations</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/alibaba-damo-academy/PDMO.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/alibaba-damo-academy/PDMO.jl/blob/main/docs/src/S4_api/formulations.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><p><strong>Formulations</strong></p><p>This page documents the problem formulation utilities in PDMO.jl.</p><p><strong>Core Data Types</strong></p><p><em>Block Components</em></p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PDMO.BlockID" href="#PDMO.BlockID"><code>PDMO.BlockID</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">BlockVariable</code></pre><p>A container representing a block variable in a larger optimization problem.</p><p><strong>Fields</strong></p><ul><li><code>id::Union{Int, String}</code>: A unique identifier for the block. This can be either an integer or a string.</li><li><code>f::AbstractFunction</code>: A function that should be smooth.</li><li><code>g::AbstractFunction</code>: A function that should be proximal.</li><li><code>val::NumericVariable</code>: The variable associated with this block.</li></ul><p>A default constructor is provided with <code>BlockVariable(idx::Int64=0)</code>, which initializes <code>f</code> and <code>g</code> with <code>Zero()</code>  and <code>val</code> with <code>0.0</code>. A block is considered uninitialized when <code>block_idx ≤ 0</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alibaba-damo-academy/PDMO.jl/blob/f9655eb086c3ecd8c696a020c3469680100c1cd5/src/Formulations/BlockVariable.jl#L1-L14">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PDMO.BlockVariable" href="#PDMO.BlockVariable"><code>PDMO.BlockVariable</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">BlockVariable(id::BlockID=&quot;&quot;)</code></pre><p>Construct a new block variable with the specified ID.</p><p><strong>Arguments</strong></p><ul><li><code>id::BlockID=&quot;&quot;</code>: The identifier for the block. Can be an integer or string. Default is an empty string.</li></ul><p><strong>Returns</strong></p><ul><li><code>BlockVariable</code>: A new BlockVariable instance with the given ID and default Zero functions.</li></ul><p><strong>Throws</strong></p><ul><li><code>ErrorException</code>: If <code>id</code> is a negative integer.</li></ul><p><strong>Notes</strong></p><ul><li>If <code>id</code> is an empty string, a warning is issued that it might be overwritten later.</li><li>The block is initialized with <code>Zero()</code> functions for both <code>f</code> and <code>g</code>, and <code>0.0</code> for <code>val</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alibaba-damo-academy/PDMO.jl/blob/f9655eb086c3ecd8c696a020c3469680100c1cd5/src/Formulations/BlockVariable.jl#L24-L41">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PDMO.BlockConstraint" href="#PDMO.BlockConstraint"><code>PDMO.BlockConstraint</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">BlockConstraint</code></pre><p>Maintains a collection of block variable indices and associated mappings.</p><p><strong>Fields</strong></p><ul><li><code>id::BlockID</code>: A unique identifier for this constraint.</li><li><code>involvedBlocks::Vector{BlockID}</code>: A vector of block IDs; these indices are kept in increasing order.</li><li><code>mappings::Dict{BlockID, AbstractMapping}</code>: A dictionary mapping block IDs to their corresponding linear mappings.</li><li><code>rhs::NumericVariable</code>: The right-hand side of the constraint.</li></ul><p>The constraint enforces a relationship of the form</p><pre><code class="nohighlight hljs">Σ (mapping(x[id])) = rhs</code></pre><p>over the blocks indexed in <code>involvedBlocks</code>. A default constructor is provided with <code>id = -1</code>, indicating an uninitialized state.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alibaba-damo-academy/PDMO.jl/blob/f9655eb086c3ecd8c696a020c3469680100c1cd5/src/Formulations/BlockConstraint.jl#L1-L18">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PDMO.MultiblockProblem" href="#PDMO.MultiblockProblem"><code>PDMO.MultiblockProblem</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">MultiblockProblem</code></pre><p>A container for a multiblock optimization problem. This structure maintains a collection of block variables and a collection of block constraints.</p><p><strong>Fields</strong></p><ul><li><code>blocks::Vector{BlockVariable}</code>: A vector of block variables.</li><li><code>constraints::Vector{BlockConstraint}</code>: A vector of block constraints.</li></ul><p>A default constructor is provided that initializes both collections as empty.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alibaba-damo-academy/PDMO.jl/blob/f9655eb086c3ecd8c696a020c3469680100c1cd5/src/Formulations/MultiblockProblem.jl#L1-L12">source</a></section></article><p><em>Block Component Functions</em></p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PDMO.addBlockVariable!" href="#PDMO.addBlockVariable!"><code>PDMO.addBlockVariable!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">addBlockVariable!(mbp::MultiblockProblem, block::BlockVariable)</code></pre><p>Add a block variable to the multiblock problem. If the block has a default ID, a new unique ID is assigned. Otherwise, the ID is checked for uniqueness.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alibaba-damo-academy/PDMO.jl/blob/f9655eb086c3ecd8c696a020c3469680100c1cd5/src/Formulations/MultiblockProblem.jl#L19-L24">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PDMO.addBlockConstraint!" href="#PDMO.addBlockConstraint!"><code>PDMO.addBlockConstraint!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">addBlockConstraint!(mbp::MultiblockProblem, constraint::BlockConstraint)</code></pre><p>Add a block constraint to the multiblock problem. If the constraint has a default ID, a new unique ID is assigned. Otherwise, the ID is checked for uniqueness.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alibaba-damo-academy/PDMO.jl/blob/f9655eb086c3ecd8c696a020c3469680100c1cd5/src/Formulations/MultiblockProblem.jl#L45-L50">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PDMO.checkBlockVariableValidity" href="#PDMO.checkBlockVariableValidity"><code>PDMO.checkBlockVariableValidity</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">checkBlockVariableValidity(block::BlockVariable; addScalarFunctionWrapper::Bool=true) -&gt; Bool</code></pre><p>Check if a block variable is valid for use in optimization problems.</p><p>This function performs several validation steps:</p><ol><li>Checks if the block ID is properly initialized (not negative for integer IDs)</li><li>Verifies that <code>f</code> is a smooth function</li><li>Verifies that <code>g</code> is a proximal function</li><li>Optionally adds scalar function wrappers if needed</li><li>Tests function evaluations, gradients, and proximal operators</li></ol><p><strong>Arguments</strong></p><ul><li><code>block::BlockVariable</code>: The block variable to validate</li><li><code>addScalarFunctionWrapper::Bool=true</code>: Whether to automatically add scalar function wrappers if needed</li></ul><p><strong>Returns</strong></p><ul><li><code>Bool</code>: <code>true</code> if the block is valid, <code>false</code> otherwise</li></ul><p><strong>Notes</strong></p><ul><li>Errors encountered during function evaluations are caught and reported, returning <code>false</code></li><li>Detailed error messages are printed to help diagnose issues</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alibaba-damo-academy/PDMO.jl/blob/f9655eb086c3ecd8c696a020c3469680100c1cd5/src/Formulations/BlockVariable.jl#L83-L105">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PDMO.checkBlockConstraintValidity" href="#PDMO.checkBlockConstraintValidity"><code>PDMO.checkBlockConstraintValidity</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">checkBlockConstraintValidity(constr::BlockConstraint) -&gt; Bool</code></pre><p>Check if a block constraint is valid.</p><p><strong>Arguments</strong></p><ul><li><code>constr::BlockConstraint</code>: The constraint to check.</li></ul><p><strong>Returns</strong></p><ul><li><code>Bool</code>: <code>true</code> if the constraint is valid, <code>false</code> otherwise.</li></ul><p><strong>Notes</strong></p><ul><li>A valid constraint must:<ol><li>Have a properly initialized ID (not negative for integer IDs)</li><li>Have matching lengths for <code>involvedBlocks</code> and <code>mappings</code></li><li>Have at least 2 blocks in <code>involvedBlocks</code></li><li>Have a mapping for each block in <code>involvedBlocks</code></li></ol></li><li>Detailed error messages are printed for invalid constraints.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alibaba-damo-academy/PDMO.jl/blob/f9655eb086c3ecd8c696a020c3469680100c1cd5/src/Formulations/BlockConstraint.jl#L267-L285">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PDMO.checkMultiblockProblemValidity" href="#PDMO.checkMultiblockProblemValidity"><code>PDMO.checkMultiblockProblemValidity</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">checkMultiblockProblemValidity(mbp::MultiblockProblem; addWrapper::Bool=true)</code></pre><p>Check whether the given multiblock problem is valid.</p><p><strong>Arguments</strong></p><ul><li><code>mbp::MultiblockProblem</code>: The multiblock problem to check.</li><li><code>addWrapper::Bool=true</code>: Flag to add wrapper for scalar input functions.</li></ul><p><strong>Returns</strong></p><ul><li><code>Bool</code>: <code>true</code> if the problem is valid, <code>false</code> otherwise.</li></ul><p><strong>Implementation Details</strong></p><p>The function checks the validity of each block variable and constraint. It also attempts to evaluate the primal residuals of each constraint with the initial solution to ensure the problem is well-formed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alibaba-damo-academy/PDMO.jl/blob/f9655eb086c3ecd8c696a020c3469680100c1cd5/src/Formulations/MultiblockProblem.jl#L72-L88">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PDMO.checkMultiblockProblemFeasibility" href="#PDMO.checkMultiblockProblemFeasibility"><code>PDMO.checkMultiblockProblemFeasibility</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">checkMultiblockProblemFeasibility(mbp::MultiblockProblem)</code></pre><p>Check the feasibility of the current solution in the multiblock problem.</p><p><strong>Arguments</strong></p><ul><li><code>mbp::MultiblockProblem</code>: The multiblock problem to check.</li></ul><p><strong>Returns</strong></p><ul><li><code>Float64</code>: The L2 norm of the constraint violations.</li><li><code>Float64</code>: The infinity norm of the constraint violations.</li></ul><p><strong>Implementation Details</strong></p><p>The function computes the constraint violations for each constraint using the current values in the block variables, and returns both the L2 and infinity norms of these violations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alibaba-damo-academy/PDMO.jl/blob/f9655eb086c3ecd8c696a020c3469680100c1cd5/src/Formulations/MultiblockProblem.jl#L120-L135">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PDMO.checkCompositeProblemValidity!" href="#PDMO.checkCompositeProblemValidity!"><code>PDMO.checkCompositeProblemValidity!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">checkCompositeProblemValidity!(mbp::MultiblockProblem)</code></pre><p>The input is a mbp with (p+1) blocks: </p><pre><code class="nohighlight hljs">min sum_{i=1}^p (f_i(x_i) + g_i(x_i)) + g_{p+1}(x_{p+1})
s.t. A1x1 + A2x2 + ... + Apxp - x_{p+1} = 0</code></pre><p>The function checks that if the input mbp is of the form described above. If x_{p+1} is      identified, this block wil be moved to the end of mbp.blocks. </p><p><strong>Arguments</strong></p><ul><li><code>mbp::MultiblockProblem</code>: The multiblock problem to check.</li></ul><p><strong>Returns</strong></p><ul><li><code>Bool</code>: <code>true</code> if the problem is a valid composite form, <code>false</code> otherwise.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alibaba-damo-academy/PDMO.jl/blob/f9655eb086c3ecd8c696a020c3469680100c1cd5/src/Formulations/MultiblockProblem.jl#L188-L206">source</a></section></article><p><strong>Graph Formulations</strong></p><p><em>Graph Data Types</em></p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PDMO.MultiblockGraph" href="#PDMO.MultiblockGraph"><code>PDMO.MultiblockGraph</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">MultiblockGraph</code></pre><p>Graph representation of a multi-block optimization problem. Contains nodes representing variables and constraints, connected by edges.</p><p><strong>Fields</strong></p><ul><li><code>nodes::Dict{String, Node}</code>: Dictionary mapping node IDs to Node objects</li><li><code>edges::Dict{String, Edge}</code>: Dictionary mapping edge IDs to Edge objects</li><li><code>colors::Dict{String, Int64}</code>: Node coloring used for bipartiteness testing (0 or 1)</li><li><code>isBipartite::Bool</code>: Whether the graph is bipartite (updated by analysis functions)</li><li><code>isConnected::Bool</code>: Whether the graph is connected (updated by analysis functions)</li></ul><p><strong>Constructors</strong></p><pre><code class="nohighlight hljs">MultiblockGraph()
MultiblockGraph(mbp::MultiblockProblem)</code></pre><p><strong>Graph Structure</strong></p><p>The graph represents the constraint structure of a multiblock optimization problem:</p><ul><li><strong>Variable nodes</strong>: Represent optimization variable blocks</li><li><strong>Constraint nodes</strong>: Represent constraints involving more than 2 blocks</li><li><strong>Two-block edges</strong>: Direct connections between variable nodes (2-block constraints)</li><li><strong>Multi-block edges</strong>: Connections from variable nodes to constraint nodes (&gt;2-block constraints)</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Create graph from a multiblock problem
mbp = MultiblockProblem()
# ... add blocks and constraints to mbp ...
graph = MultiblockGraph(mbp)

# Analyze graph properties
is_bipartite = isMultiblockGraphBipartite(graph)
is_connected = isMultiblockGraphConnected(graph)</code></pre><p><strong>Usage</strong></p><p>This representation is particularly useful for:</p><ul><li>Algorithm selection (e.g., choosing between different decomposition methods)</li><li>Problem analysis (connectivity, bipartiteness)</li><li>Graph-based optimization algorithms like ADMM</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alibaba-damo-academy/PDMO.jl/blob/f9655eb086c3ecd8c696a020c3469680100c1cd5/src/Formulations/MultiblockGraph.jl#L187-L228">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PDMO.NodeType" href="#PDMO.NodeType"><code>PDMO.NodeType</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">NodeType</code></pre><p>An enumeration defining the types of nodes in a multiblock graph.</p><p><strong>Values</strong></p><ul><li><code>VARIABLE_NODE</code>: Node representing a variable block from the original problem</li><li><code>CONSTRAINT_NODE</code>: Node representing a constraint from the original problem</li></ul><p><strong>Usage</strong></p><p>Node types are used to distinguish between variable blocks and constraints in the graph representation. Variable nodes correspond to optimization variables, while constraint nodes represent constraints that involve more than two blocks.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alibaba-damo-academy/PDMO.jl/blob/f9655eb086c3ecd8c696a020c3469680100c1cd5/src/Formulations/MultiblockGraph.jl#L27-L40">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PDMO.EdgeType" href="#PDMO.EdgeType"><code>PDMO.EdgeType</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">EdgeType</code></pre><p>An enumeration defining the types of edges in a multiblock graph.</p><p><strong>Values</strong></p><ul><li><code>TWO_BLOCK_EDGE</code>: Edge connecting exactly two variable nodes (representing a constraint involving two blocks)</li><li><code>MULTIBLOCK_EDGE</code>: Edge connecting a variable node to a constraint node (representing participation in a multi-block constraint)</li></ul><p><strong>Usage</strong></p><p>Edge types distinguish between constraints that involve exactly two blocks (represented as direct edges between variable nodes) and constraints that involve more than two blocks (represented as edges from variable nodes to constraint nodes).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alibaba-damo-academy/PDMO.jl/blob/f9655eb086c3ecd8c696a020c3469680100c1cd5/src/Formulations/MultiblockGraph.jl#L71-L84">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PDMO.Node" href="#PDMO.Node"><code>PDMO.Node</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Node</code></pre><p>A node in the multi-block graph representing either a variable block or a constraint.</p><p><strong>Fields</strong></p><ul><li><code>neighbors::Vector{String}</code>: List of edge IDs connected to this node</li><li><code>type::NodeType</code>: Type of node (VARIABLE<em>NODE or CONSTRAINT</em>NODE)</li><li><code>source::BlockID</code>: ID of the original variable block or constraint from the MultiblockProblem</li></ul><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">Node(neighbors::Vector{String}, type::NodeType, source::BlockID)</code></pre><p><strong>Usage</strong></p><p>Nodes are automatically created when constructing a MultiblockGraph from a MultiblockProblem. Variable nodes are created for each block variable, and constraint nodes are created for constraints involving more than two blocks.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alibaba-damo-academy/PDMO.jl/blob/f9655eb086c3ecd8c696a020c3469680100c1cd5/src/Formulations/MultiblockGraph.jl#L46-L63">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PDMO.Edge" href="#PDMO.Edge"><code>PDMO.Edge</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Edge</code></pre><p>An edge in the multi-block graph connecting two nodes.</p><p><strong>Fields</strong></p><ul><li><code>nodeID1::String</code>: ID of the first node connected by this edge</li><li><code>nodeID2::String</code>: ID of the second node connected by this edge (constraint node for MULTIBLOCK_EDGE)</li><li><code>type::EdgeType</code>: Type of edge (TWO<em>BLOCK</em>EDGE or MULTIBLOCK_EDGE)</li><li><code>sourceBlockConstraint::BlockID</code>: ID of the constraint from the original problem that this edge represents</li><li><code>sourceBlockVariable::BlockID</code>: For MULTIBLOCK<em>EDGE, the variable block ID; empty string for TWO</em>BLOCK_EDGE</li></ul><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">Edge(nodeID1::String, nodeID2::String, type::EdgeType, sourceBlockConstraint::BlockID, sourceBlockVariable::BlockID)</code></pre><p><strong>Usage</strong></p><p>Edges are automatically created when constructing a MultiblockGraph from a MultiblockProblem.</p><ul><li>TWO<em>BLOCK</em>EDGE connects two variable nodes directly (constraint involves exactly 2 blocks)</li><li>MULTIBLOCK_EDGE connects a variable node to a constraint node (constraint involves &gt;2 blocks)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alibaba-damo-academy/PDMO.jl/blob/f9655eb086c3ecd8c696a020c3469680100c1cd5/src/Formulations/MultiblockGraph.jl#L90-L109">source</a></section></article><p><em>Graph Construction Functions</em></p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PDMO.createNodeID" href="#PDMO.createNodeID"><code>PDMO.createNodeID</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">createNodeID(id::BlockID; isConstraint::Bool=false) -&gt; String</code></pre><p>Generate a unique node ID string from a block or constraint ID.</p><p><strong>Arguments</strong></p><ul><li><code>id::BlockID</code>: The block or constraint ID from the original MultiblockProblem</li><li><code>isConstraint::Bool=false</code>: If true, generates a constraint node ID; otherwise generates a variable node ID</li></ul><p><strong>Returns</strong></p><ul><li>A string ID that uniquely identifies the node in the graph</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Create a variable node ID
var_node_id = createNodeID(&quot;Block1&quot;)  # Returns &quot;VariableNode(Block1)&quot;

# Create a constraint node ID
constr_node_id = createNodeID(&quot;Constraint1&quot;, isConstraint=true)  # Returns &quot;ConstraintNode(Constraint1)&quot;</code></pre><p><strong>Usage</strong></p><p>This function is used internally when constructing a MultiblockGraph to create unique identifiers for nodes. The generated IDs follow a consistent naming convention to distinguish between variable nodes and constraint nodes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alibaba-damo-academy/PDMO.jl/blob/f9655eb086c3ecd8c696a020c3469680100c1cd5/src/Formulations/MultiblockGraph.jl#L118-L143">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PDMO.createEdgeID" href="#PDMO.createEdgeID"><code>PDMO.createEdgeID</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">createEdgeID(constrID::BlockID; variableID::BlockID=&quot;&quot;) -&gt; String</code></pre><p>Generate a unique edge ID string from constraint and variable IDs.</p><p><strong>Arguments</strong></p><ul><li><code>constrID::BlockID</code>: The constraint ID from the original MultiblockProblem</li><li><code>variableID::BlockID=&quot;&quot;</code>: The variable ID (empty for TWO<em>BLOCK</em>EDGE, specified for MULTIBLOCK_EDGE)</li></ul><p><strong>Returns</strong></p><ul><li>A string ID that uniquely identifies the edge in the graph</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Create a two-block edge ID (constraint involves exactly 2 blocks)
two_block_edge_id = createEdgeID(&quot;Constraint1&quot;)  # Returns &quot;TwoBlockEdge(Constraint1)&quot;

# Create a multiblock edge ID (constraint involves &gt;2 blocks)
multi_edge_id = createEdgeID(&quot;Constraint2&quot;, variableID=&quot;Block1&quot;)  # Returns &quot;MultiblockEdge(Constraint2, Block1)&quot;</code></pre><p><strong>Usage</strong></p><p>This function is used internally when constructing a MultiblockGraph to create unique identifiers for edges. The type of edge ID depends on whether a variableID is provided:</p><ul><li>No variableID: TWO<em>BLOCK</em>EDGE (direct connection between two variable nodes)</li><li>With variableID: MULTIBLOCK_EDGE (connection from variable node to constraint node)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alibaba-damo-academy/PDMO.jl/blob/f9655eb086c3ecd8c696a020c3469680100c1cd5/src/Formulations/MultiblockGraph.jl#L152-L178">source</a></section></article><p><em>Graph Analysis Functions</em></p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PDMO.numberNodes" href="#PDMO.numberNodes"><code>PDMO.numberNodes</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">numberNodes(graph::MultiblockGraph) -&gt; Int</code></pre><p>Returns the total number of nodes in the graph.</p><p><strong>Arguments</strong></p><ul><li><code>graph::MultiblockGraph</code>: The graph to analyze</li></ul><p><strong>Returns</strong></p><ul><li>The number of nodes</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alibaba-damo-academy/PDMO.jl/blob/f9655eb086c3ecd8c696a020c3469680100c1cd5/src/Formulations/MultiblockGraph.jl#L432-L442">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PDMO.numberEdges" href="#PDMO.numberEdges"><code>PDMO.numberEdges</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">numberEdges(graph::MultiblockGraph) -&gt; Int</code></pre><p>Returns the total number of edges in the graph.</p><p><strong>Arguments</strong></p><ul><li><code>graph::MultiblockGraph</code>: The graph to analyze</li></ul><p><strong>Returns</strong></p><ul><li>The number of edges</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alibaba-damo-academy/PDMO.jl/blob/f9655eb086c3ecd8c696a020c3469680100c1cd5/src/Formulations/MultiblockGraph.jl#L447-L457">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PDMO.numberEdgesByTypes" href="#PDMO.numberEdgesByTypes"><code>PDMO.numberEdgesByTypes</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">numberEdgesByTypes(graph::MultiblockGraph) -&gt; Tuple{Int, Int}</code></pre><p>Counts the number of edges of each type in the graph.</p><p><strong>Arguments</strong></p><ul><li><code>graph::MultiblockGraph</code>: The graph to analyze</li></ul><p><strong>Returns</strong></p><ul><li>A tuple containing (count of two-block edges, count of multi-block edges)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alibaba-damo-academy/PDMO.jl/blob/f9655eb086c3ecd8c696a020c3469680100c1cd5/src/Formulations/MultiblockGraph.jl#L462-L472">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PDMO.getNodelNeighbors" href="#PDMO.getNodelNeighbors"><code>PDMO.getNodelNeighbors</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">getNodelNeighbors(graph::MultiblockGraph) -&gt; Dict{String, Set{String}}</code></pre><p>Constructs an adjacency list representation of the graph.</p><p><strong>Arguments</strong></p><ul><li><code>graph::MultiblockGraph</code>: The graph to analyze</li></ul><p><strong>Returns</strong></p><ul><li>A dictionary mapping each node ID to a set of its neighboring node IDs</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alibaba-damo-academy/PDMO.jl/blob/f9655eb086c3ecd8c696a020c3469680100c1cd5/src/Formulations/MultiblockGraph.jl#L241-L251">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PDMO.isMultiblockGraphBipartite" href="#PDMO.isMultiblockGraphBipartite"><code>PDMO.isMultiblockGraphBipartite</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">isMultiblockGraphBipartite(graph::MultiblockGraph) -&gt; Bool</code></pre><p>Determines if the graph is bipartite using a breadth-first search coloring algorithm. Updates the <code>colors</code> and <code>isBipartite</code> fields in the graph.</p><p><strong>Arguments</strong></p><ul><li><code>graph::MultiblockGraph</code>: The graph to analyze</li></ul><p><strong>Returns</strong></p><ul><li><code>true</code> if the graph is bipartite, <code>false</code> otherwise</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alibaba-damo-academy/PDMO.jl/blob/f9655eb086c3ecd8c696a020c3469680100c1cd5/src/Formulations/MultiblockGraph.jl#L261-L272">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PDMO.isMultiblockGraphConnected" href="#PDMO.isMultiblockGraphConnected"><code>PDMO.isMultiblockGraphConnected</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">isMultiblockGraphConnected(graph::MultiblockGraph) -&gt; Bool</code></pre><p>Determines if the graph is connected using a breadth-first search traversal. Updates the <code>isConnected</code> field in the graph.</p><p><strong>Arguments</strong></p><ul><li><code>graph::MultiblockGraph</code>: The graph to analyze</li></ul><p><strong>Returns</strong></p><ul><li><code>true</code> if the graph is connected, <code>false</code> otherwise</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alibaba-damo-academy/PDMO.jl/blob/f9655eb086c3ecd8c696a020c3469680100c1cd5/src/Formulations/MultiblockGraph.jl#L305-L316">source</a></section></article><p><strong>Bipartization Algorithms</strong></p><p><em>Bipartization Types</em></p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PDMO.BipartizationAlgorithm" href="#PDMO.BipartizationAlgorithm"><code>PDMO.BipartizationAlgorithm</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">BipartizationAlgorithm</code></pre><p>An enumeration defining the available bipartization algorithms.</p><p><strong>Values</strong></p><ul><li><p><code>MILP_BIPARTIZATION</code>: Mixed Integer Linear Programming approach</p><ul><li>Optimal solution that minimizes operator norms and graph complexity</li><li>Slowest but highest quality results</li><li>Uses HiGHS solver for optimization</li></ul></li><li><p><code>BFS_BIPARTIZATION</code>: Breadth-First Search based approach</p><ul><li>Fast heuristic using BFS traversal</li><li>Assigns nodes to alternating partitions</li><li>Splits edges when conflicts are detected</li></ul></li><li><p><code>DFS_BIPARTIZATION</code>: Depth-First Search based approach  </p><ul><li>Fast heuristic using DFS traversal</li><li>Similar to BFS but with different traversal order</li><li>May produce different partitioning results</li></ul></li><li><p><code>SPANNING_TREE_BIPARTIZATION</code>: Spanning tree with smart back edge processing</p><ul><li>Balanced approach between quality and speed</li><li>Builds spanning tree and processes back edges intelligently</li><li>Minimizes unnecessary edge splits</li></ul></li></ul><p><strong>Usage</strong></p><p>These enum values are used with <code>getBipartizationAlgorithmName()</code> and as identifiers for selecting bipartization algorithms in optimization routines.</p><p><strong>Algorithm Selection Guidelines</strong></p><ul><li>Use <code>MILP_BIPARTIZATION</code> for optimal results when computational time is not critical</li><li>Use <code>BFS_BIPARTIZATION</code> or <code>DFS_BIPARTIZATION</code> for fast heuristic solutions</li><li>Use <code>SPANNING_TREE_BIPARTIZATION</code> for a good balance between speed and quality</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alibaba-damo-academy/PDMO.jl/blob/f9655eb086c3ecd8c696a020c3469680100c1cd5/src/Formulations/BipartizationAlgorithms.jl#L41-L75">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PDMO.BfsBipartization" href="#PDMO.BfsBipartization"><code>PDMO.BfsBipartization</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">BfsBipartization(graph::MultiblockGraph, mbp::MultiblockProblem, 
                nodesAssignment::Dict{String, Int64}, 
                edgesSplitting::Dict{String, Tuple{Int64, Int64}})</code></pre><p>Bipartization algorithm using Breadth-First Search (BFS).</p><p>This algorithm uses BFS traversal to quickly assign nodes to partitions and create a bipartite graph by splitting edges when conflicts are detected.</p><p><strong>Arguments</strong></p><ul><li><code>graph::MultiblockGraph</code>: The graph to bipartize</li><li><code>mbp::MultiblockProblem</code>: The original multiblock problem (not used in algorithm, included for interface consistency)</li><li><code>nodesAssignment::Dict{String, Int64}</code>: Dictionary to store node partition assignments (0 for left, 1 for right)</li><li><code>edgesSplitting::Dict{String, Tuple{Int64, Int64}}</code>: Dictionary to store edge splitting decisions (a,b) where:<ul><li>a = 0: edge not split, a = 1: edge split</li><li>b = 0: assigned to left partition, b = 1: assigned to right partition</li></ul></li></ul><p><strong>Algorithm Steps</strong></p><ol><li><strong>Neighbor Construction</strong>: Build adjacency list from graph edges</li><li><strong>Connected Components</strong>: Process each connected component separately</li><li><strong>BFS Traversal</strong>: Starting from unvisited nodes, perform BFS with alternating partition assignment</li><li><strong>Conflict Detection</strong>: When adjacent nodes would have the same partition, split the connecting edge</li><li><strong>Edge Processing</strong>: Set splitting decisions for all edges (split or keep)</li></ol><p><strong>BFS Process</strong></p><ul><li><strong>Queue-Based</strong>: Uses FIFO queue for breadth-first traversal</li><li><strong>Alternating Assignment</strong>: Assigns nodes to alternating partitions (0, 1, 0, 1, ...)</li><li><strong>Conflict Resolution</strong>: Splits edges when both endpoints would be in the same partition</li><li><strong>Component Handling</strong>: Alternates starting partition for different connected components</li></ul><p><strong>Advantages</strong></p><ul><li><strong>Fast Execution</strong>: O(V + E) time complexity where V = vertices, E = edges</li><li><strong>Simple Implementation</strong>: Straightforward algorithm with predictable behavior</li><li><strong>Memory Efficient</strong>: Minimal memory overhead beyond input graph</li><li><strong>Handles Disconnected Graphs</strong>: Automatically processes all connected components</li></ul><p><strong>Disadvantages</strong></p><ul><li><strong>Suboptimal Results</strong>: May split more edges than necessary</li><li><strong>No Operator Norm Consideration</strong>: Ignores numerical properties of the original problem</li><li><strong>Traversal Order Dependence</strong>: Results may depend on node iteration order</li></ul><p><strong>Usage</strong></p><p>This algorithm is recommended when:</p><ul><li>Fast execution is more important than optimal results</li><li>The graph is large and MILP would be too slow</li><li>A reasonable bipartite approximation is sufficient</li><li>Operator norm considerations are not critical</li></ul><p><strong>Implementation Notes</strong></p><ul><li>Processes connected components independently</li><li>Alternates starting partition (0, 1, 0, 1, ...) for different components</li><li>All unprocessed edges are marked as not split (0, 0)</li><li>The dictionaries <code>nodesAssignment</code> and <code>edgesSplitting</code> are cleared and populated by the algorithm</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alibaba-damo-academy/PDMO.jl/blob/f9655eb086c3ecd8c696a020c3469680100c1cd5/src/Formulations/BipartizationAlgorithms.jl#L296-L351">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PDMO.MilpBipartization" href="#PDMO.MilpBipartization"><code>PDMO.MilpBipartization</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">MilpBipartization(graph::MultiblockGraph, mbp::MultiblockProblem, 
                 nodesAssignment::Dict{String, Int64}, 
                 edgesSplitting::Dict{String, Tuple{Int64, Int64}})</code></pre><p>Bipartization algorithm using Mixed Integer Linear Programming (MILP).</p><p>This algorithm formulates the graph bipartization problem as an optimization problem that  finds the optimal bipartite structure while minimizing operator norms and graph complexity.</p><p><strong>Arguments</strong></p><ul><li><code>graph::MultiblockGraph</code>: The graph to bipartize</li><li><code>mbp::MultiblockProblem</code>: The original multiblock problem (used for operator norm calculations)</li><li><code>nodesAssignment::Dict{String, Int64}</code>: Dictionary to store node partition assignments (0 for left, 1 for right)</li><li><code>edgesSplitting::Dict{String, Tuple{Int64, Int64}}</code>: Dictionary to store edge splitting decisions (a,b) where:<ul><li>a = 0: edge not split, a = 1: edge split</li><li>b = 0: assigned to left partition, b = 1: assigned to right partition</li></ul></li></ul><p><strong>Algorithm Steps</strong></p><ol><li><strong>Variable Creation</strong>: Binary variables for node assignments and edge splitting decisions</li><li><strong>Constraint Formulation</strong>: Ensures each node belongs to exactly one partition</li><li><strong>Bipartite Constraints</strong>: Prevents adjacent nodes from being in the same partition (or splits the edge)</li><li><strong>Objective Optimization</strong>: Minimizes operator norms and graph complexity</li><li><strong>Solution Extraction</strong>: Converts optimal solution to node assignments and edge splitting decisions</li></ol><p><strong>Mathematical Formulation</strong></p><ul><li><strong>Variables</strong>: <code>x_node_L[i]</code>, <code>x_node_R[i]</code> (node assignments), <code>z_edge[e]</code> (edge splitting), <code>x_edge_L[e]</code>, <code>x_edge_R[e]</code> (edge assignments)</li><li><strong>Constraints</strong>: Partition constraints, bipartite constraints, edge splitting logic</li><li><strong>Objective</strong>: <code>min t_L + t_R + complexity_terms</code> where <code>t_L</code>, <code>t_R</code> are operator norm bounds</li></ul><p><strong>Advantages</strong></p><ul><li><strong>Optimal Solution</strong>: Finds the best bipartization according to the objective function</li><li><strong>Operator Norm Awareness</strong>: Considers the numerical properties of the original problem</li><li><strong>Principled Approach</strong>: Mathematical optimization rather than heuristic</li></ul><p><strong>Disadvantages</strong></p><ul><li><strong>Computational Cost</strong>: Slower than heuristic methods, especially for large graphs</li><li><strong>Solver Dependency</strong>: Requires HiGHS or another MILP solver</li><li><strong>Memory Usage</strong>: May require significant memory for large problems</li></ul><p><strong>Usage</strong></p><p>This algorithm is recommended when solution quality is more important than computational speed, particularly for problems where operator norm considerations are critical for numerical stability.</p><p><strong>Implementation Notes</strong></p><ul><li>Uses HiGHS solver with silent mode enabled</li><li>Automatically handles both TWO<em>BLOCK</em>EDGE and MULTIBLOCK_EDGE types</li><li>Operator norms are computed using the <code>operatorNorm2</code> function from the mappings</li><li>The dictionaries <code>nodesAssignment</code> and <code>edgesSplitting</code> are cleared and populated by the algorithm</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alibaba-damo-academy/PDMO.jl/blob/f9655eb086c3ecd8c696a020c3469680100c1cd5/src/Formulations/BipartizationAlgorithms.jl#L133-L183">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PDMO.DfsBipartization" href="#PDMO.DfsBipartization"><code>PDMO.DfsBipartization</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">DfsBipartization(graph::MultiblockGraph, mbp::MultiblockProblem, 
                nodesAssignment::Dict{String, Int64}, 
                edgesSplitting::Dict{String, Tuple{Int64, Int64}})</code></pre><p>Bipartization algorithm using Depth-First Search (DFS).</p><p>This algorithm uses DFS traversal to assign nodes to partitions and create a bipartite graph by splitting edges when conflicts are detected. Similar to BFS but with different traversal order.</p><p><strong>Arguments</strong></p><ul><li><code>graph::MultiblockGraph</code>: The graph to bipartize</li><li><code>mbp::MultiblockProblem</code>: The original multiblock problem (not used in algorithm, included for interface consistency)</li><li><code>nodesAssignment::Dict{String, Int64}</code>: Dictionary to store node partition assignments (0 for left, 1 for right)</li><li><code>edgesSplitting::Dict{String, Tuple{Int64, Int64}}</code>: Dictionary to store edge splitting decisions (a,b) where:<ul><li>a = 0: edge not split, a = 1: edge split</li><li>b = 0: assigned to left partition, b = 1: assigned to right partition</li></ul></li></ul><p><strong>Algorithm Steps</strong></p><ol><li><strong>Neighbor Construction</strong>: Build adjacency list from graph edges</li><li><strong>Connected Components</strong>: Process each connected component separately</li><li><strong>DFS Traversal</strong>: Starting from unvisited nodes, perform DFS with alternating partition assignment</li><li><strong>Conflict Detection</strong>: When adjacent nodes would have the same partition, split the connecting edge</li><li><strong>Edge Processing</strong>: Set splitting decisions for all edges (split or keep)</li></ol><p><strong>DFS Process</strong></p><ul><li><strong>Stack-Based</strong>: Uses LIFO stack for depth-first traversal</li><li><strong>Alternating Assignment</strong>: Assigns nodes to alternating partitions (0, 1, 0, 1, ...)</li><li><strong>Conflict Resolution</strong>: Splits edges when both endpoints would be in the same partition</li><li><strong>Component Handling</strong>: Alternates starting partition for different connected components</li></ul><p><strong>Advantages</strong></p><ul><li><strong>Fast Execution</strong>: O(V + E) time complexity where V = vertices, E = edges</li><li><strong>Simple Implementation</strong>: Straightforward algorithm with predictable behavior</li><li><strong>Memory Efficient</strong>: Minimal memory overhead beyond input graph</li><li><strong>Handles Disconnected Graphs</strong>: Automatically processes all connected components</li><li><strong>Different Traversal Pattern</strong>: May produce different (sometimes better) results than BFS</li></ul><p><strong>Disadvantages</strong></p><ul><li><strong>Suboptimal Results</strong>: May split more edges than necessary</li><li><strong>No Operator Norm Consideration</strong>: Ignores numerical properties of the original problem</li><li><strong>Traversal Order Dependence</strong>: Results may depend on node iteration order</li><li><strong>Stack Depth</strong>: May require significant stack space for deep graphs</li></ul><p><strong>Comparison with BFS</strong></p><ul><li><strong>Traversal Order</strong>: DFS explores deeply before backtracking, BFS explores level by level</li><li><strong>Memory Usage</strong>: DFS uses implicit recursion stack, BFS uses explicit queue</li><li><strong>Results</strong>: May produce different partitioning results for the same graph</li><li><strong>Performance</strong>: Similar time complexity, but different memory access patterns</li></ul><p><strong>Usage</strong></p><p>This algorithm is recommended when:</p><ul><li>Fast execution is more important than optimal results</li><li>You want to try a different heuristic than BFS</li><li>The graph structure might benefit from depth-first exploration</li><li>Operator norm considerations are not critical</li></ul><p><strong>Implementation Notes</strong></p><ul><li>Uses explicit stack with <code>pop!()</code> for LIFO behavior (vs <code>popfirst!()</code> for BFS)</li><li>Processes connected components independently</li><li>Alternates starting partition (0, 1, 0, 1, ...) for different components</li><li>All unprocessed edges are marked as not split (0, 0)</li><li>The dictionaries <code>nodesAssignment</code> and <code>edgesSplitting</code> are cleared and populated by the algorithm</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alibaba-damo-academy/PDMO.jl/blob/f9655eb086c3ecd8c696a020c3469680100c1cd5/src/Formulations/BipartizationAlgorithms.jl#L404-L468">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PDMO.SpanningTreeBipartization" href="#PDMO.SpanningTreeBipartization"><code>PDMO.SpanningTreeBipartization</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SpanningTreeBipartization(graph::MultiblockGraph, mbp::MultiblockProblem, 
                         nodesAssignment::Dict{String, Int64}, 
                         edgesSplitting::Dict{String, Tuple{Int64, Int64}})</code></pre><p>Bipartization algorithm using Spanning Tree with Smart Back Edge Processing.</p><p>This algorithm provides a balanced approach between solution quality and computational efficiency  by intelligently processing edges based on their role in the graph structure.</p><p><strong>Arguments</strong></p><ul><li><code>graph::MultiblockGraph</code>: The graph to bipartize</li><li><code>mbp::MultiblockProblem</code>: The original multiblock problem (not used in algorithm, included for interface consistency)</li><li><code>nodesAssignment::Dict{String, Int64}</code>: Dictionary to store node partition assignments (0 for left, 1 for right)</li><li><code>edgesSplitting::Dict{String, Tuple{Int64, Int64}}</code>: Dictionary to store edge splitting decisions (a,b) where:<ul><li>a = 0: edge not split, a = 1: edge split</li><li>b = 0: assigned to left partition, b = 1: assigned to right partition</li></ul></li></ul><p><strong>Algorithm Steps</strong></p><ol><li><strong>Spanning Tree Construction</strong>: Build spanning tree using DFS traversal</li><li><strong>Tree Coloring</strong>: 2-color the spanning tree (trees are always bipartite)</li><li><strong>Edge Classification</strong>: Classify edges as tree edges or back edges</li><li><strong>Smart Back Edge Processing</strong>: Only split back edges if endpoints have the same color</li><li><strong>Edge Decision Assignment</strong>: Set splitting decisions for all edges</li></ol><p><strong>Mathematical Foundation</strong></p><ul><li><strong>Spanning Tree Property</strong>: Any tree is bipartite and can be 2-colored</li><li><strong>Back Edge Analysis</strong>: A back edge preserves bipartiteness if its endpoints have different colors</li><li><strong>Optimal Splitting</strong>: Only splits edges that would violate bipartiteness</li></ul><p><strong>Algorithm Process</strong></p><ul><li><strong>Tree Edges</strong>: Always kept intact (never split) since they maintain bipartite structure</li><li><strong>Back Edges with Different Colors</strong>: Kept intact (already valid for bipartite graph)</li><li><strong>Back Edges with Same Color</strong>: Split to avoid violating bipartiteness</li><li><strong>Connected Components</strong>: Each component processed independently</li></ul><p><strong>Advantages</strong></p><ul><li><strong>Balanced Approach</strong>: Good compromise between speed and solution quality</li><li><strong>Minimal Splitting</strong>: Splits only edges that truly violate bipartiteness</li><li><strong>Deterministic</strong>: Always produces the same result for the same graph</li><li><strong>Handles Disconnected Graphs</strong>: Automatically processes all connected components</li><li><strong>Mathematically Sound</strong>: Based on solid graph theory principles</li></ul><p><strong>Disadvantages</strong></p><ul><li><strong>No Operator Norm Consideration</strong>: Ignores numerical properties of the original problem</li><li><strong>Spanning Tree Dependence</strong>: Results may depend on which spanning tree is chosen</li><li><strong>Not Globally Optimal</strong>: May not find the absolute minimum number of splits</li></ul><p><strong>Comparison with Other Algorithms</strong></p><ul><li><strong>vs MILP</strong>: Faster but may not be globally optimal</li><li><strong>vs BFS/DFS</strong>: Usually produces fewer edge splits due to intelligent edge processing</li><li><strong>vs Naive Spanning Tree</strong>: Much more efficient (doesn&#39;t split all back edges)</li></ul><p><strong>Usage</strong></p><p>This algorithm is recommended when:</p><ul><li>You want a balance between solution quality and computational speed</li><li>The graph has many cycles (where back edge processing provides benefits)</li><li>You prefer a deterministic algorithm over heuristics</li><li>Operator norm considerations are not critical</li></ul><p><strong>Implementation Notes</strong></p><ul><li>Uses DFS to build spanning tree for each connected component</li><li>Maintains separate sets for visited nodes and tree edges</li><li>2-colors the spanning tree using BFS</li><li>All back edges are analyzed for potential splitting</li><li>The dictionaries <code>nodesAssignment</code> and <code>edgesSplitting</code> are cleared and populated by the algorithm</li></ul><p><strong>Time Complexity</strong></p><ul><li><strong>Spanning Tree Construction</strong>: O(V + E)</li><li><strong>Tree Coloring</strong>: O(V + E)</li><li><strong>Back Edge Processing</strong>: O(E)</li><li><strong>Overall</strong>: O(V + E) where V = vertices, E = edges</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alibaba-damo-academy/PDMO.jl/blob/f9655eb086c3ecd8c696a020c3469680100c1cd5/src/Formulations/BipartizationAlgorithms.jl#L521-L594">source</a></section></article><p><em>Bipartization Functions</em></p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PDMO.getBipartizationAlgorithmName" href="#PDMO.getBipartizationAlgorithmName"><code>PDMO.getBipartizationAlgorithmName</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">getBipartizationAlgorithmName(alg::BipartizationAlgorithm) -&gt; String</code></pre><p>Returns a human-readable string representation of a bipartization algorithm.</p><p><strong>Arguments</strong></p><ul><li><code>alg::BipartizationAlgorithm</code>: The bipartization algorithm enum value</li></ul><p><strong>Returns</strong></p><ul><li>A string representing the algorithm name, or &quot;Unknown bipartization algorithm&quot; for invalid inputs</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">alg = BFS_BIPARTIZATION
name = getBipartizationAlgorithmName(alg)  # Returns &quot;BFS_BIPARTIZATION&quot;

alg = MILP_BIPARTIZATION
name = getBipartizationAlgorithmName(alg)  # Returns &quot;MILP_BIPARTIZATION&quot;</code></pre><p><strong>Usage</strong></p><p>This function is useful for:</p><ul><li>Logging and debugging (identifying which algorithm is being used)</li><li>User interfaces (displaying algorithm names)</li><li>Report generation (documenting algorithm choices)</li><li>Error messages and diagnostics</li></ul><p><strong>Supported Algorithms</strong></p><ul><li><code>MILP_BIPARTIZATION</code> → &quot;MILP_BIPARTIZATION&quot;</li><li><code>BFS_BIPARTIZATION</code> → &quot;BFS_BIPARTIZATION&quot;  </li><li><code>DFS_BIPARTIZATION</code> → &quot;DFS_BIPARTIZATION&quot;</li><li><code>SPANNING_TREE_BIPARTIZATION</code> → &quot;SPANNING<em>TREE</em>BIPARTIZATION&quot;</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alibaba-damo-academy/PDMO.jl/blob/f9655eb086c3ecd8c696a020c3469680100c1cd5/src/Formulations/BipartizationAlgorithms.jl#L86-L118">source</a></section></article><p><strong>ADMM Bipartite Graph</strong></p><p><em>ADMM Data Types</em></p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PDMO.ADMMBipartiteGraph" href="#PDMO.ADMMBipartiteGraph"><code>PDMO.ADMMBipartiteGraph</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ADMMBipartiteGraph</code></pre><p>A bipartite graph representation specifically designed for the Alternating Direction Method of Multipliers (ADMM) algorithm.</p><p>This structure transforms a general multiblock optimization problem into a bipartite graph that enables efficient ADMM decomposition. The bipartite structure ensures that variables can be updated in alternating fashion between the two partitions, which is essential for ADMM convergence properties.</p><p><strong>Fields</strong></p><ul><li><code>nodes::Dict{String, ADMMNode}</code>: Dictionary mapping node IDs to ADMMNode objects<ul><li>Contains original variable nodes, constraint nodes, and auxiliary split nodes</li><li>Each node has associated optimization functions and partition assignment</li></ul></li><li><code>edges::Dict{String, ADMMEdge}</code>: Dictionary mapping edge IDs to ADMMEdge objects<ul><li>Represents linear constraints between nodes in the bipartite graph</li><li>Each edge defines coupling relationships for ADMM algorithm</li></ul></li><li><code>mbpBlockID2admmNodeID::Dict{BlockID, String}</code>: Mapping from original MultiblockProblem block IDs to ADMM node IDs<ul><li>Enables traceability between original problem formulation and ADMM representation</li><li>Used for solution extraction and result interpretation</li></ul></li><li><code>left::Vector{String}</code>: Node IDs assigned to the left partition (typically assignment = 0)</li><li><code>right::Vector{String}</code>: Node IDs assigned to the right partition (typically assignment = 1)</li></ul><p><strong>Bipartite Structure Properties</strong></p><ul><li><strong>Partition Guarantee</strong>: No edges exist between nodes in the same partition</li><li><strong>ADMM Compatibility</strong>: Structure enables alternating updates between partitions</li><li><strong>Constraint Preservation</strong>: All original constraints are represented through edges</li><li><strong>Auxiliary Nodes</strong>: May contain additional nodes created during bipartization</li></ul><p><strong>Graph Construction Process</strong></p><ol><li><strong>Node Creation</strong>: Transform MultiblockProblem blocks into ADMM nodes</li><li><strong>Edge Creation</strong>: Transform constraints into ADMM edges</li><li><strong>Bipartization</strong>: Apply bipartization algorithm if necessary</li><li><strong>Edge Splitting</strong>: Create auxiliary nodes and edges to maintain bipartite structure</li><li><strong>Partition Assignment</strong>: Assign nodes to left/right partitions</li><li><strong>Validation</strong>: Verify bipartite property and constraint preservation</li></ol><p><strong>Constructors</strong></p><pre><code class="nohighlight hljs">ADMMBipartiteGraph()  # Empty graph
ADMMBipartiteGraph(graph::MultiblockGraph, mbp::MultiblockProblem, nodesAssignment, edgesSplitting)
ADMMBipartiteGraph(graph::MultiblockGraph, mbp::MultiblockProblem, algorithm::BipartizationAlgorithm)</code></pre><p><strong>Usage in ADMM Algorithm</strong></p><ul><li><strong>x-update</strong>: Update variables in one partition (typically left)</li><li><strong>z-update</strong>: Update variables in other partition (typically right)</li><li><strong>Dual update</strong>: Update Lagrange multipliers associated with edges</li><li><strong>Residual computation</strong>: Compute primal and dual residuals using edge constraints</li><li><strong>Convergence check</strong>: Monitor constraint violations and variable changes</li></ul><p><strong>Mathematical Representation</strong></p><p>For a bipartite graph with partitions L (left) and R (right):</p><ul><li>Variables: x<em>L (left partition), x</em>R (right partition)</li><li>Constraints: Each edge (i,j) with i∈L, j∈R represents A<em>i x</em>i + A<em>j x</em>j = b_{ij}</li><li>ADMM updates alternate between optimizing over x<em>L and x</em>R</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Create from MultiblockProblem with specific algorithm
mbp = MultiblockProblem()
# ... add blocks and constraints ...
graph = MultiblockGraph(mbp)
admm_graph = ADMMBipartiteGraph(graph, mbp, BFS_BIPARTIZATION)

# Access graph properties
println(&quot;Left partition size: &quot;, length(admm_graph.left))
println(&quot;Right partition size: &quot;, length(admm_graph.right))
println(&quot;Number of constraints: &quot;, length(admm_graph.edges))</code></pre><p><strong>Related Types</strong></p><ul><li><code>ADMMNode</code>: Individual nodes in the bipartite graph</li><li><code>ADMMEdge</code>: Edges representing constraints between nodes</li><li><code>MultiblockGraph</code>: Original graph representation before bipartization</li><li><code>BipartizationAlgorithm</code>: Algorithms for ensuring bipartite structure</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alibaba-damo-academy/PDMO.jl/blob/f9655eb086c3ecd8c696a020c3469680100c1cd5/src/Formulations/ADMMBipartiteGraph.jl#L240-L313">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PDMO.ADMMNode" href="#PDMO.ADMMNode"><code>PDMO.ADMMNode</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ADMMNode</code></pre><p>A node in the ADMM bipartite graph representation for the Alternating Direction Method of Multipliers.</p><p>ADMMNode represents either an original variable block from the multiblock problem or an auxiliary node created from edge splitting during bipartization. Each node contains optimization functions and  maintains connectivity information for the ADMM algorithm.</p><p><strong>Fields</strong></p><ul><li><code>f::AbstractFunction</code>: Primary objective function component (smooth part of the objective)</li><li><code>g::AbstractFunction</code>: Secondary objective function component (non-smooth part, often regularization or constraint indicators)</li><li><code>val::NumericVariable</code>: Current value/estimate of the variable associated with this node</li><li><code>neighbors::Set{String}</code>: Set of edge IDs connected to this node in the bipartite graph</li><li><code>convertedEdgeID::String</code>: Original edge ID from MultiblockGraph if this node was created by splitting an edge; empty string for original variable nodes</li><li><code>assignment::Int</code>: Partition assignment in the bipartite graph (0 for left partition, 1 for right partition)</li></ul><p><strong>Node Types</strong></p><ol><li><p><strong>Original Variable Nodes</strong>: Represent variable blocks from the original MultiblockProblem</p><ul><li>Have non-trivial <code>f</code> and <code>g</code> functions from the original block</li><li><code>convertedEdgeID</code> is empty string</li><li><code>val</code> initialized from original block value</li></ul></li><li><p><strong>Constraint Nodes</strong>: Represent multi-block constraints from the original problem</p><ul><li>Have <code>f = Zero()</code> and <code>g = IndicatorSumOfNVariables(...)</code></li><li>Created for constraints involving more than 2 blocks</li><li><code>convertedEdgeID</code> is empty string</li></ul></li><li><p><strong>Split Edge Nodes</strong>: Auxiliary nodes created during bipartization</p><ul><li>Created when edges need to be split to maintain bipartite structure</li><li>Have specific function configurations depending on split type</li><li><code>convertedEdgeID</code> contains the original edge ID</li></ul></li></ol><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">ADMMNode(f, g, val, neighbors, convertedEdgeID, assignment)</code></pre><p><strong>Usage in ADMM</strong></p><ul><li><strong>Left Partition</strong>: Typically contains variable nodes for x-update step</li><li><strong>Right Partition</strong>: Typically contains constraint nodes and auxiliary nodes for z-update step</li><li><strong>Functions</strong>: Used in proximal operators during ADMM iterations</li><li><strong>Connectivity</strong>: Determines the coupling structure in ADMM decomposition</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Original variable node
node = ADMMNode(QuadraticFunction(...), IndicatorBox(...), x0, Set{String}(), &quot;&quot;, 0)

# Constraint node  
node = ADMMNode(Zero(), IndicatorSumOfNVariables(...), z0, Set{String}(), &quot;&quot;, 1)

# Split edge auxiliary node
node = ADMMNode(Zero(), IndicatorSumOfNVariables(2, rhs), aux_val, Set{String}(), &quot;EdgeID123&quot;, 1)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alibaba-damo-academy/PDMO.jl/blob/f9655eb086c3ecd8c696a020c3469680100c1cd5/src/Formulations/ADMMBipartiteGraph.jl#L1-L54">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PDMO.ADMMEdge" href="#PDMO.ADMMEdge"><code>PDMO.ADMMEdge</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ADMMEdge</code></pre><p>An edge in the ADMM bipartite graph connecting two nodes and representing a constraint in the ADMM decomposition.</p><p>ADMMEdge represents a linear constraint between two nodes in the bipartite graph. Each edge corresponds to either an original constraint from the multiblock problem or a constraint created during edge splitting for bipartization. The edge defines the coupling between variables in the ADMM algorithm.</p><p><strong>Fields</strong></p><ul><li><code>nodeID1::String</code>: ID of the first node connected by this edge (typically from left partition)</li><li><code>nodeID2::String</code>: ID of the second node connected by this edge (typically from right partition)</li><li><code>mappings::Dict{String, AbstractMapping}</code>: Linear mappings for each node involved in the constraint<ul><li>Key: node ID, Value: linear mapping applied to that node&#39;s variable</li><li>Represents the coefficient matrices in the linear constraint</li></ul></li><li><code>rhs::NumericVariable</code>: Right-hand side vector/value of the constraint represented by this edge</li><li><code>splittedEdgeID::String</code>: Original edge ID from MultiblockGraph if this edge was created by splitting; empty string for original edges</li></ul><p><strong>Edge Types</strong></p><ol><li><p><strong>Original Two-Block Edges</strong>: Direct constraints between two variable blocks</p><ul><li>Represent constraints of the form <code>A₁x₁ + A₂x₂ = b</code></li><li>Connect two original variable nodes</li><li><code>splittedEdgeID</code> is empty string</li></ul></li><li><p><strong>Multi-Block Edges</strong>: Constraints involving constraint nodes</p><ul><li>Represent constraints of the form <code>Aᵢxᵢ - zⱼ = 0</code></li><li>Connect a variable node to a constraint node</li><li><code>splittedEdgeID</code> is empty string</li></ul></li><li><p><strong>Split Edges</strong>: Edges created from splitting original edges</p><ul><li>Created during bipartization to maintain bipartite structure</li><li>Connect original nodes to auxiliary split nodes</li><li><code>splittedEdgeID</code> contains the original edge ID</li></ul></li></ol><p><strong>Mathematical Representation</strong></p><p>Each edge represents a constraint: <code>mapping[nodeID1] * x₁ + mapping[nodeID2] * x₂ = rhs</code></p><ul><li>For node i with variable xᵢ, the constraint contribution is <code>mappings[nodeIDᵢ](xᵢ)</code></li><li>The complete constraint equation must equal the <code>rhs</code> value</li></ul><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">ADMMEdge(nodeID1, nodeID2, mappings, rhs, splittedEdgeID)</code></pre><p><strong>Usage in ADMM</strong></p><ul><li><strong>Constraint Coupling</strong>: Defines how variables are coupled in the optimization problem</li><li><strong>Dual Variables</strong>: Each edge corresponds to dual variables (Lagrange multipliers) in ADMM</li><li><strong>Update Steps</strong>: Used in both primal and dual update steps of the ADMM algorithm</li><li><strong>Convergence</strong>: Residuals computed using these constraint definitions</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Original two-block constraint: A₁x₁ + A₂x₂ = b
mappings = Dict(&quot;node1&quot; =&gt; LinearMappingMatrix(A1), &quot;node2&quot; =&gt; LinearMappingMatrix(A2))
edge = ADMMEdge(&quot;node1&quot;, &quot;node2&quot;, mappings, b, &quot;&quot;)

# Multi-block constraint connection: Aᵢxᵢ - zⱼ = 0
mappings = Dict(&quot;var_node&quot; =&gt; LinearMappingMatrix(A), &quot;constr_node&quot; =&gt; LinearMappingExtraction(...))
edge = ADMMEdge(&quot;var_node&quot;, &quot;constr_node&quot;, mappings, zeros(m), &quot;&quot;)

# Split edge constraint: Aᵢxᵢ - z₁ = 0 (from splitting)
mappings = Dict(&quot;original_node&quot; =&gt; LinearMappingMatrix(A), &quot;split_node&quot; =&gt; LinearMappingExtraction(...))
edge = ADMMEdge(&quot;original_node&quot;, &quot;split_node&quot;, mappings, zeros(m), &quot;OriginalEdgeID&quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alibaba-damo-academy/PDMO.jl/blob/f9655eb086c3ecd8c696a020c3469680100c1cd5/src/Formulations/ADMMBipartiteGraph.jl#L64-L126">source</a></section></article><p><em>ADMM Construction Functions</em></p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PDMO.createADMMNodeID" href="#PDMO.createADMMNodeID"><code>PDMO.createADMMNodeID</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">createADMMNodeID(edgeID::String) -&gt; String</code></pre><p>Generate a unique node ID for an auxiliary node created from splitting an edge during bipartization.</p><p>When an edge needs to be split to maintain bipartite structure, this function creates a consistent naming scheme for the new auxiliary node that will be inserted at the split point.</p><p><strong>Arguments</strong></p><ul><li><code>edgeID::String</code>: The original edge ID from the MultiblockGraph that is being split</li></ul><p><strong>Returns</strong></p><ul><li>A string ID for the new ADMM auxiliary node following the pattern &quot;ADMMNodeConvertedFromEdge(edgeID)&quot;</li></ul><p><strong>Usage</strong></p><p>This function is used internally during the construction of ADMMBipartiteGraph when:</p><ul><li>A TWO<em>BLOCK</em>EDGE needs to be split due to bipartization decisions</li><li>A MULTIBLOCK_EDGE needs to be split to maintain bipartite structure</li><li>The bipartization algorithm determines that an edge violates bipartiteness</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">original_edge_id = &quot;TwoBlockEdge(Constraint1)&quot;
new_node_id = createADMMNodeID(original_edge_id)
# Returns: &quot;ADMMNodeConvertedFromEdge(TwoBlockEdge(Constraint1))&quot;

multiblock_edge_id = &quot;MultiblockEdge(Constraint2, Block1)&quot;  
aux_node_id = createADMMNodeID(multiblock_edge_id)
# Returns: &quot;ADMMNodeConvertedFromEdge(MultiblockEdge(Constraint2, Block1))&quot;</code></pre><p><strong>Implementation Notes</strong></p><ul><li>The generated ID uniquely identifies the auxiliary node</li><li>The ID preserves traceability back to the original edge</li><li>Used consistently across edge splitting operations</li><li>Prevents ID conflicts with original variable and constraint nodes</li></ul><p><strong>Related Functions</strong></p><ul><li><code>createADMMEdgeID</code>: Creates IDs for new edges connected to split nodes</li><li><code>ADMMBipartiteGraph</code>: Uses this function during edge splitting operations</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alibaba-damo-academy/PDMO.jl/blob/f9655eb086c3ecd8c696a020c3469680100c1cd5/src/Formulations/ADMMBipartiteGraph.jl#L135-L175">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PDMO.createADMMEdgeID" href="#PDMO.createADMMEdgeID"><code>PDMO.createADMMEdgeID</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">createADMMEdgeID(edgeID::String, nodeID::String) -&gt; String</code></pre><p>Generate a unique edge ID for a new edge created when splitting an original edge during bipartization.</p><p>When an original edge is split to maintain bipartite structure, it is replaced by two or more new edges that connect through an auxiliary node. This function creates consistent IDs for these new edges.</p><p><strong>Arguments</strong></p><ul><li><code>edgeID::String</code>: The original edge ID from the MultiblockGraph that was split</li><li><code>nodeID::String</code>: The ID of the node that this new edge connects to (either original node or auxiliary node)</li></ul><p><strong>Returns</strong></p><ul><li>A string ID for the new ADMM edge following the pattern &quot;ADMMEdgeSplittedFrom(edgeID, nodeID)&quot;</li></ul><p><strong>Usage</strong></p><p>This function is used internally during edge splitting operations when:</p><ul><li>An original TWO<em>BLOCK</em>EDGE is split into two edges through an auxiliary node</li><li>A MULTIBLOCK_EDGE is split to resolve bipartite violations</li><li>Multiple new edges need to be created with consistent, traceable naming</li></ul><p><strong>Edge Splitting Scenarios</strong></p><ol><li><p><strong>TWO<em>BLOCK</em>EDGE Split</strong>: Original edge (node1, node2) becomes:</p><ul><li>Edge1: (node1, auxNode) with ID &quot;ADMMEdgeSplittedFrom(originalEdgeID, node1)&quot;</li><li>Edge2: (node2, auxNode) with ID &quot;ADMMEdgeSplittedFrom(originalEdgeID, node2)&quot;</li></ul></li><li><p><strong>MULTIBLOCK_EDGE Split</strong>: Original edge (varNode, constrNode) becomes:</p><ul><li>Edge1: (varNode, auxNode) with ID &quot;ADMMEdgeSplittedFrom(originalEdgeID, varNode)&quot;</li><li>Edge2: (constrNode, auxNode) with ID &quot;ADMMEdgeSplittedFrom(originalEdgeID, constrNode)&quot;</li></ul></li></ol><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Splitting a two-block edge
original_edge = &quot;TwoBlockEdge(Constraint1)&quot;
edge1_id = createADMMEdgeID(original_edge, &quot;VariableNode(Block1)&quot;)
# Returns: &quot;ADMMEdgeSplittedFrom(TwoBlockEdge(Constraint1), VariableNode(Block1))&quot;

edge2_id = createADMMEdgeID(original_edge, &quot;VariableNode(Block2)&quot;)  
# Returns: &quot;ADMMEdgeSplittedFrom(TwoBlockEdge(Constraint1), VariableNode(Block2))&quot;

# Connection to auxiliary node
aux_node_id = &quot;ADMMNodeConvertedFromEdge(TwoBlockEdge(Constraint1))&quot;
aux_edge_id = createADMMEdgeID(original_edge, aux_node_id)
# Returns: &quot;ADMMEdgeSplittedFrom(TwoBlockEdge(Constraint1), ADMMNodeConvertedFromEdge(...))&quot;</code></pre><p><strong>Implementation Notes</strong></p><ul><li>Preserves full traceability back to the original edge and connected node</li><li>Ensures unique IDs even when multiple edges are created from the same original edge</li><li>Used consistently across all edge splitting operations</li><li>Enables reconstruction of the splitting history for debugging and analysis</li></ul><p><strong>Related Functions</strong></p><ul><li><code>createADMMNodeID</code>: Creates IDs for auxiliary nodes in edge splits</li><li><code>ADMMBipartiteGraph</code>: Uses this function extensively during bipartization</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alibaba-damo-academy/PDMO.jl/blob/f9655eb086c3ecd8c696a020c3469680100c1cd5/src/Formulations/ADMMBipartiteGraph.jl#L180-L235">source</a></section></article><p><strong>JuMP Interface</strong></p><p><em>JuMP Interface Functions</em></p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PDMO.solveMultiblockProblemByJuMP" href="#PDMO.solveMultiblockProblemByJuMP"><code>PDMO.solveMultiblockProblemByJuMP</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">solveMultiblockProblemByJuMP(mbp::MultiblockProblem)</code></pre><p>Solve a multiblock problem using JuMP and Ipopt.</p><p><strong>Arguments</strong></p><ul><li><code>mbp::MultiblockProblem</code>: The multiblock problem to solve.</li></ul><p><strong>Returns</strong></p><ul><li><code>Float64</code>: The optimal objective value found by the solver.</li></ul><p><strong>Implementation Details</strong></p><p>The function:</p><ol><li>Converts the multiblock problem to a JuMP model</li><li>Sets up the Ipopt solver with HSL linear solver</li><li>Creates JuMP variables for each block variable</li><li>Adds constraints from the multiblock problem</li><li>Formulates the objective function (handling both linear/quadratic and nonlinear terms)</li><li>Solves the problem and returns the objective value</li></ol><p>Currently, only LinearMappingMatrix and LinearMappingIdentity are supported for mappings.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alibaba-damo-academy/PDMO.jl/blob/f9655eb086c3ecd8c696a020c3469680100c1cd5/src/Formulations/MultiblockProblemJuMP.jl#L365-L386">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PDMO.isSupportedObjectiveFunction" href="#PDMO.isSupportedObjectiveFunction"><code>PDMO.isSupportedObjectiveFunction</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">isSupportedObjectiveFunction(f::AbstractFunction) -&gt; Bool</code></pre><p>Check if a function type is supported for JuMP objective formulation, including wrapped functions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alibaba-damo-academy/PDMO.jl/blob/f9655eb086c3ecd8c696a020c3469680100c1cd5/src/Formulations/MultiblockProblemJuMP.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PDMO.isSupportedProximalFunction" href="#PDMO.isSupportedProximalFunction"><code>PDMO.isSupportedProximalFunction</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">isSupportedProximalFunction(g::AbstractFunction) -&gt; Bool</code></pre><p>Check if a function type is supported for JuMP constraint formulation, including wrapped functions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alibaba-damo-academy/PDMO.jl/blob/f9655eb086c3ecd8c696a020c3469680100c1cd5/src/Formulations/MultiblockProblemJuMP.jl#L22-L26">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PDMO.unwrapFunction" href="#PDMO.unwrapFunction"><code>PDMO.unwrapFunction</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">unwrapFunction(f::AbstractFunction) -&gt; (originalFunction, scaling, translation)</code></pre><p>Unwrap a function, returning the original function and transformation parameters. For non-wrapped functions, returns (f, 1.0, 0.0).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alibaba-damo-academy/PDMO.jl/blob/f9655eb086c3ecd8c696a020c3469680100c1cd5/src/Formulations/MultiblockProblemJuMP.jl#L49-L54">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PDMO.addBlockVariableToJuMPModel!" href="#PDMO.addBlockVariableToJuMPModel!"><code>PDMO.addBlockVariableToJuMPModel!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">addBlockVariableToJuMPModel!(model::JuMP.Model, 
                           f::AbstractFunction,
                           g::AbstractFunction,
                           x::NumericVariable,
                           blockID::BlockID, 
                           var::Union{Dict{BlockID, Vector{JuMP.VariableRef}}, Dict{String, Vector{JuMP.VariableRef}}}, 
                           aux::Union{Dict{BlockID, Vector{JuMP.VariableRef}}, Dict{String, Vector{JuMP.VariableRef}}}, 
                           objExpressions::Vector{Union{JuMP.AffExpr, JuMP.QuadExpr}})</code></pre><p>Add a block variable to a JuMP model.</p><p><strong>Arguments</strong></p><ul><li><code>model::JuMP.Model</code>: The JuMP model to which the variable will be added.</li><li><code>f::AbstractFunction</code>: The smooth function component of the block variable.</li><li><code>g::AbstractFunction</code>: The nonsmooth function component of the block variable.</li><li><code>x::NumericVariable</code>: The current value of the block variable.</li><li><code>blockID::BlockID</code>: The ID of the block variable.</li><li><code>var::Union{Dict{BlockID, Vector{JuMP.VariableRef}}, Dict{String, Vector{JuMP.VariableRef}}}</code>: Dictionary to store the created JuMP variables.</li><li><code>aux::Union{Dict{BlockID, Vector{JuMP.VariableRef}}, Dict{String, Vector{JuMP.VariableRef}}}</code>: Dictionary to store auxiliary JuMP variables.</li><li><code>objExpressions::Vector{Union{JuMP.AffExpr, JuMP.QuadExpr}}</code>: Vector to collect objective expressions.</li></ul><p><strong>Returns</strong></p><ul><li><code>Bool</code>: <code>true</code> if the block has a nonlinear smooth function, <code>false</code> otherwise.</li></ul><p><strong>Implementation Details</strong></p><p>The function creates JuMP variables and constraints based on the types of <code>f</code> and <code>g</code>.  It supports various function types including QuadraticFunction, AffineFunction,  ComponentwiseExponentialFunction for smooth functions, and IndicatorBox, IndicatorBallL2,  IndicatorSumOfNVariables, ElementwiseL1Norm, IndicatorHyperplane, IndicatorSOC for nonsmooth functions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/alibaba-damo-academy/PDMO.jl/blob/f9655eb086c3ecd8c696a020c3469680100c1cd5/src/Formulations/MultiblockProblemJuMP.jl#L66-L96">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../main/">« Main</a><a class="docs-footer-nextpage" href="../functions/">Functions »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Tuesday 22 July 2025 05:12">Tuesday 22 July 2025</span>. Using Julia version 1.11.6.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
